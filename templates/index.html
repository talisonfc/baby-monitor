<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baby Monitor</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 900px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
        }
        
        #video-stream {
            width: 100%;
            height: auto;
            display: block;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        #toggle-audio {
            background: #667eea;
            color: white;
        }
        
        #toggle-audio:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        #toggle-audio.muted {
            background: #e74c3c;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: #f8f9fa;
            border-radius: 25px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #95a5a6;
            animation: pulse 2s infinite;
        }
        
        .status-indicator.connected {
            background: #2ecc71;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        
        .info {
            text-align: center;
            margin-top: 20px;
            color: #7f8c8d;
            font-size: 14px;
        }
        
        .ios-help {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }
        
        .ios-help h3 {
            color: #856404;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .ios-help ul {
            text-align: left;
            color: #856404;
            font-size: 13px;
            margin-left: 20px;
        }
        
        .ios-help li {
            margin-bottom: 5px;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }
            
            .container {
                padding: 20px;
            }
            
            button {
                padding: 10px 20px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üë∂ Baby Monitor</h1>
        
        <div class="video-container">
            <img id="video-stream" src="{{ url_for('video_feed') }}" alt="Video Stream">
        </div>
        
        <div class="controls">
            <button id="toggle-audio">üîä Audio On</button>
            <div class="status">
                <div class="status-indicator" id="connection-status"></div>
                <span id="status-text">Connecting...</span>
            </div>
            <div class="status" id="audio-status" style="display: none;">
                <div class="status-indicator connected"></div>
                <span id="audio-status-text">Playing</span>
            </div>
        </div>
        
        <div class="info">
            <p>Video streaming at 640x480 | Audio streaming at 44.1kHz</p>
        </div>
        
        <div class="ios-help" id="ios-help">
            <h3>üì± iPhone Audio Setup</h3>
            <ul>
                <li>Turn <strong>volume UP</strong> to maximum</li>
                <li>Turn <strong>Silent Mode OFF</strong> (check switch on left side)</li>
                <li>Keep this tab <strong>active</strong> (don't switch apps)</li>
                <li>Wait 5-10 seconds after enabling audio</li>
                <li>If no sound: close tab completely and reopen</li>
            </ul>
        </div>
    </div>

    <script>
        const socket = io();
        let audioEnabled = false;
        const toggleButton = document.getElementById('toggle-audio');
        const statusIndicator = document.getElementById('connection-status');
        const statusText = document.getElementById('status-text');
        const audioStatusDiv = document.getElementById('audio-status');
        const audioStatusText = document.getElementById('audio-status-text');
        
        // Detect mobile device
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        console.log('üîç Device type:', isMobile ? 'Mobile' : 'Desktop');
        console.log('üîç iOS:', isIOS);
        console.log('üîç User agent:', navigator.userAgent);
        
        // Show iOS help if on iOS
        if (isIOS) {
            document.getElementById('ios-help').style.display = 'block';
        }
        
        // Audio playback using Web Audio API with better buffering
        let audioContext = null;
        let gainNode = null;
        let audioQueue = [];
        let nextStartTime = 0;
        let isPlaying = false;
        let audioChunksReceived = 0;
        const SAMPLE_RATE = 44100;
        
        async function initAudioContext() {
            if (!audioContext) {
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    audioContext = new AudioContextClass({
                        latencyHint: 'interactive',
                        sampleRate: SAMPLE_RATE
                    });
                    
                    // Create gain node for volume control
                    gainNode = audioContext.createGain();
                    gainNode.gain.value = isMobile ? 5.0 : 2.0; // Much higher boost for mobile
                    gainNode.connect(audioContext.destination);
                    
                    console.log('‚úÖ Audio context created');
                    console.log('Sample rate:', audioContext.sampleRate);
                    console.log('State:', audioContext.state);
                } catch (error) {
                    console.error('‚ùå Failed to create audio context:', error);
                    throw error;
                }
            }
            
            // Resume audio context (required for mobile) - try multiple times
            let attempts = 0;
            while (audioContext.state !== 'running' && attempts < 5) {
                attempts++;
                console.log(`üîÑ Attempt ${attempts} to resume audio context...`);
                await audioContext.resume();
                await new Promise(resolve => setTimeout(resolve, 100));
                console.log('Audio context state:', audioContext.state);
            }
            
            if (audioContext.state !== 'running') {
                throw new Error('Failed to start audio context after ' + attempts + ' attempts. State: ' + audioContext.state);
            }
            
            console.log('‚úÖ Audio context resumed, state:', audioContext.state);
            return audioContext;
        }
        
        async function scheduleAudioChunk(audioData) {
            if (!audioContext) {
                console.warn('‚ö†Ô∏è No audio context');
                return;
            }
            
            // Resume if suspended (critical for mobile)
            if (audioContext.state !== 'running') {
                console.warn('‚ö†Ô∏è Audio context suspended, resuming...');
                try {
                    await audioContext.resume();
                    console.log('‚úÖ Audio context resumed');
                } catch (error) {
                    console.error('‚ùå Failed to resume:', error);
                    return;
                }
            }
            
            try {
                // Convert base64 to ArrayBuffer
                const binaryString = atob(audioData);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                // Convert Int16 to Float32
                const int16Array = new Int16Array(bytes.buffer);
                const float32Array = new Float32Array(int16Array.length);
                for (let i = 0; i < int16Array.length; i++) {
                    float32Array[i] = int16Array[i] / 32768.0;
                }
                
                // Create audio buffer
                const audioBuffer = audioContext.createBuffer(1, float32Array.length, SAMPLE_RATE);
                audioBuffer.getChannelData(0).set(float32Array);
                
                // Create buffer source and schedule
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                
                // Connect through gain node (volume control works on all devices)
                source.connect(gainNode);
                
                // Schedule seamless playback
                const currentTime = audioContext.currentTime;
                if (nextStartTime < currentTime) {
                    nextStartTime = currentTime + 0.01; // Small delay for iPhone
                }
                
                source.start(nextStartTime);
                nextStartTime += audioBuffer.duration;
                
                audioChunksReceived++;
                if (audioChunksReceived % 10 === 0) {
                    console.log(`üîä Playing audio chunk #${audioChunksReceived}, next at:`, nextStartTime.toFixed(3));
                }
                
                // Update UI to show audio is playing
                if (audioChunksReceived === 1 || audioChunksReceived % 50 === 0) {
                    audioStatusDiv.style.display = 'flex';
                    audioStatusText.textContent = `Playing (${audioChunksReceived} chunks)`;
                }
                
            } catch (error) {
                console.error('‚ùå Error scheduling audio:', error);
            }
        }
        
        async function processAudioQueue() {
            while (audioQueue.length > 0) {
                const chunk = audioQueue.shift();
                await scheduleAudioChunk(chunk);
            }
        }
        
        // Keep audio context alive on mobile
        function keepAudioContextAlive() {
            if (audioEnabled && audioContext && audioContext.state === 'suspended') {
                console.warn('‚ö†Ô∏è Audio context suspended, attempting to resume...');
                audioContext.resume().then(() => {
                    console.log('‚úÖ Audio context resumed by keepAlive');
                });
            }
        }
        
        // Check audio context state every second
        setInterval(keepAudioContextAlive, 1000);

        
        // Connection status
        socket.on('connect', () => {
            console.log('‚úÖ Connected to server');
            statusIndicator.classList.add('connected');
            statusText.textContent = 'Connected';
        });
        
        socket.on('disconnect', () => {
            console.log('‚ùå Disconnected from server');
            statusIndicator.classList.remove('connected');
            statusText.textContent = 'Disconnected';
        });
        
        // Audio streaming with buffering
        socket.on('audio_data', (audioData) => {
            if (!audioEnabled || !audioContext) {
                return;
            }
            
            // Resume context if suspended (iPhone Safari fix)
            if (audioContext.state === 'suspended') {
                console.warn('‚ö†Ô∏è Context suspended, resuming...');
                audioContext.resume();
            }
            
            if (audioChunksReceived % 20 === 0) {
                console.log('üì• Audio data received, queue size:', audioQueue.length, 'chunks received:', audioChunksReceived);
            }
            
            // Add to queue
            audioQueue.push(audioData);
            
            // Keep queue small (max 3 chunks to minimize latency)
            while (audioQueue.length > 3) {
                audioQueue.shift();
                console.log('‚ö†Ô∏è Dropped old chunk');
            }
            
            // Process queue
            processAudioQueue();
        });
        
        // Audio error handling
        socket.on('audio_error', (data) => {
            console.error('‚ùå Server audio error:', data.error);
            alert('Server Audio Error: ' + data.error);
            audioEnabled = false;
            toggleButton.textContent = 'üîä Audio On';
            toggleButton.classList.remove('muted');
        });
        
        // Toggle audio
        toggleButton.addEventListener('click', async () => {
            console.log('=== Audio Toggle ===');
            console.log('Current state:', audioEnabled ? 'ON' : 'OFF');
            
            // Haptic feedback on iOS
            if (isIOS && navigator.vibrate) {
                navigator.vibrate(50);
            }
            
            if (!audioEnabled) {
                // ENABLE AUDIO
                try {
                    console.log('üîä Initializing audio...');
                    
                    // Initialize audio context in user gesture
                    await initAudioContext();
                    
                    if (audioContext.state !== 'running') {
                        throw new Error('Audio context state: ' + audioContext.state);
                    }
                    
                    console.log('‚úÖ Audio context running');
                    console.log('Sample rate:', audioContext.sampleRate);
                    console.log('State:', audioContext.state);
                    console.log('Base latency:', audioContext.baseLatency);
                    
                    // iPhone CRITICAL: Play a longer silent/quiet buffer with proper gain
                    // This truly unlocks audio on iOS Safari
                    const unlockDuration = 0.1; // 100ms
                    const unlockBuffer = audioContext.createBuffer(1, audioContext.sampleRate * unlockDuration, audioContext.sampleRate);
                    const channelData = unlockBuffer.getChannelData(0);
                    
                    // Fill with quiet sine wave instead of silence
                    // iOS sometimes ignores completely silent buffers
                    for (let i = 0; i < channelData.length; i++) {
                        channelData[i] = Math.sin(2 * Math.PI * 440 * i / audioContext.sampleRate) * 0.01;
                    }
                    
                    const unlockSource = audioContext.createBufferSource();
                    unlockSource.buffer = unlockBuffer;
                    
                    // Create dedicated unlock gain node
                    const unlockGain = audioContext.createGain();
                    unlockGain.gain.value = isMobile ? 0.1 : 0.01; // Louder on mobile for better unlock
                    
                    unlockSource.connect(unlockGain);
                    unlockGain.connect(audioContext.destination);
                    unlockSource.start(0);
                    
                    // Wait for unlock buffer to complete
                    await new Promise(resolve => setTimeout(resolve, 150));
                    console.log('‚úÖ Audio unlock buffer played, context state:', audioContext.state);
                    
                    // Verify context is truly running
                    if (audioContext.state !== 'running') {
                        throw new Error('Audio context still not running after unlock. State: ' + audioContext.state);
                    }
                    
                    // Reset counter
                    audioChunksReceived = 0;
                    
                    // Enable
                    audioEnabled = true;
                    nextStartTime = audioContext.currentTime;
                    toggleButton.textContent = 'üîá Audio Off';
                    toggleButton.classList.add('muted');
                    
                    // Request stream
                    console.log('üì§ Requesting audio stream...');
                    socket.emit('start_audio');
                    console.log('‚úÖ Audio enabled successfully!');
                    
                    // Show alert for mobile users
                    if (isMobile) {
                        setTimeout(() => {
                            alert('üîä Audio Enabled!\n\nIMPORTANT for iPhone:\n‚Ä¢ TURN VOLUME UP to maximum\n‚Ä¢ DISABLE Silent Mode (check switch)\n‚Ä¢ Keep this tab ACTIVE\n‚Ä¢ Check "Playing" appears below\n‚Ä¢ Wait 5-10 seconds for audio\n\nIf no sound: Close tab and reopen');
                        }, 100);
                    }
                    
                } catch (error) {
                    console.error('‚ùå Failed:', error);
                    alert('Failed to start audio:\n' + error.message + '\n\nTry:\n1. Refresh the page\n2. Check volume settings\n3. Disable silent mode');
                    audioEnabled = false;
                    toggleButton.textContent = 'üîä Audio On';
                    toggleButton.classList.remove('muted');
                }
                
            } else {
                // DISABLE AUDIO
                console.log('üîá Disabling audio...');
                audioEnabled = false;
                toggleButton.textContent = 'üîä Audio On';
                toggleButton.classList.remove('muted');
                audioQueue = [];
                audioChunksReceived = 0;
                audioStatusDiv.style.display = 'none';
                socket.emit('stop_audio');
                console.log('‚úÖ Audio disabled');
            }
        });
    </script>
</body>
</html>
